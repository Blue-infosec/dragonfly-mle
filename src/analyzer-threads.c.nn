/* Copyright (C) 2017-2018 CounterFlow AI, Inc.
 *
 * You can copy, redistribute or modify this Program under the terms of
 * the GNU General Public License version 2 as published by the Free
 * Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * version 2 along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

/*
 *
 * author Randy Caldejon <rc@counterflowai.com>
 *
 */

#define _GNU_SOURCE

#include <pwd.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/un.h>
#include <unistd.h>
#include <syslog.h>
#include <pthread.h>
#include <errno.h>
#include <signal.h>
#include <limits.h>

#include <nanomsg/nn.h>
#include <nanomsg/ipc.h>
#include <nanomsg/pipeline.h>

#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef ENABLE_JIT
#include <luajit-2.0/luajit.h>
#endif

#include <analyzer-threads.h>
#include <suricata-cmds.h>
#include <dragonfly-cmds.h>

extern int g_verbose;
extern int g_chroot;
extern int g_iprep;
extern int g_drop_priv;

static char g_root_dir[PATH_MAX];
static char g_run_dir[PATH_MAX];
static char g_log_dir[PATH_MAX];
static char g_analyzer_dir[PATH_MAX];
static char g_config_file[PATH_MAX];

extern uint64_t g_running;

static int g_num_lua_threads = 0;
static pthread_barrier_t g_barrier;

static char *g_redis_host = "127.0.0.1";
static char *g_redis_port = "6379";
static char *g_analyzer_mode = SURICATA_MODE;

#define DNS_EVENT 0
#define FILE_EVENT 1
#define FLOW_EVENT 2
#define HTTP_EVENT 3
#define SMTP_EVENT 4
#define SSH_EVENT 5
#define TLS_EVENT 6

static const char *g_analyzer_type[] =
    {
        "dns",
        "files",
        "flow",
        "http",
        "smtp",
        "ssh",
        "tls",
        NULL};

/*
 * ---------------------------------------------------------------------------------------
 *
 * ---------------------------------------------------------------------------------------
 */
static int socket_open(char *socket_url)
{
    int rv = -1;
    int output_socket = -1;

    if ((output_socket = nn_socket(AF_SP, NN_PAIR)) < 0)
    {
        syslog(LOG_ERR, "nn_socket: %s - %s\n", socket_url, nn_strerror(errno));
        return -1;
    }
    if ((rv = nn_bind(output_socket, socket_url)) < 0)
    {
        syslog(LOG_ERR, "nn_bind: %s - %s\n", socket_url, nn_strerror(errno));
        return -1;
    }
    syslog(LOG_INFO, "%s: connected to: %s", __FUNCTION__, socket_url);
    return rv;
}

/*
 * ---------------------------------------------------------------------------------------
 *
 * ---------------------------------------------------------------------------------------
 */
static void socket_close(int socket)
{
    nn_close(socket);
}

/*
 * ---------------------------------------------------------------------------------------
 *
 * ---------------------------------------------------------------------------------------
 */
void lua_loop(lua_State *L, int socket_handle)
{
    char buffer[2048];
    memset(buffer, 0, sizeof(buffer));

    while (g_running)
    {
        int bytes = 0;
        if ((bytes = nn_recv(socket_handle, &buffer, sizeof(buffer), 0)) < 0)
        {
            if (errno == EINTR)
            {
                continue;
            }
            syslog(LOG_ERR, "socket read error: %s", strerror(errno));
            return;
        }
        else if (bytes == 0)
        {
            syslog(LOG_ERR, "connection closed; reconnecting");
            return;
        }
        lua_getglobal(L, "event");
        lua_pushlstring(L, buffer, bytes);
        if (lua_pcall(L, 1, 0, 0))
        {
            syslog(LOG_ERR, "lua_pcall error; %s", lua_tostring(L, -1));
        }
    }
}

/*
 * ---------------------------------------------------------------------------------------
 *
 * ---------------------------------------------------------------------------------------
 */
static void *lua_thread(void *ptr)
{
    const char *analyzer = (const char *)ptr;

    char lua_analyzer[PATH_MAX];
    char socket_url[PATH_MAX];
    char lua_path[PATH_MAX];

    snprintf(lua_analyzer, PATH_MAX, "%s/%s-%s.lua", g_analyzer_dir, analyzer, g_analyzer_mode);
    //snprintf(socket_url, PATH_MAX, "%s/%s-%s.ipc", g_analyzer_mode, analyzer, g_analyzer_mode);
    snprintf(socket_url, PATH_MAX, "ipc://%s/%s-%s.ipc", g_analyzer_dir, analyzer, g_analyzer_mode);

    pthread_detach(pthread_self());
    pthread_setname_np(pthread_self(), analyzer);

    /*
     * Set thread name to the file name of the lua script
     */
    lua_State *L = luaL_newstate();

    luaL_openlibs(L);
    /* set local LUA paths */
    snprintf(lua_path, PATH_MAX - 1, "package.path = package.path .. \";%s/lib/?.lua\"", g_root_dir);
    luaL_loadstring(L, lua_path);
    lua_pcall(L, 0, LUA_MULTRET, 0);

    snprintf(lua_path, PATH_MAX - 1, "package.cpath = package.cpath .. \";%s/lib/?.so\"", g_root_dir);
    luaL_loadstring(L, lua_path);
    lua_pcall(L, 0, LUA_MULTRET, 0);

//#if DISABLE_IO
    char lua_disable_modules [PATH_MAX];
    snprintf(lua_disable_modules, PATH_MAX - 1, "io=nil");
    luaL_loadstring(L, lua_disable_modules);
    lua_pcall(L, 0, LUA_MULTRET, 0);
//#endif

    syslog(LOG_INFO, "Loading %s", lua_analyzer);
    lua_pushstring(L, g_analyzer_mode);
    lua_setglobal(L, "analyzer_mode");

    if (luaL_loadfile(L, lua_analyzer) || lua_pcall(L, 0, 0, 0))
    {
        syslog(LOG_ERR, "luaL_loadfile %s failed - %s", lua_analyzer, lua_tostring(L, -1));
        pthread_exit(NULL);
    }

    /* globally set redis host and port number in the LUA engine */
    lua_pushstring(L, g_redis_host);
    lua_setglobal(L, "redis_host");    
    lua_pushstring(L, g_redis_port);
    lua_setglobal(L, "redis_port");

    /* register functions */
    lua_pushcfunction(L, dragonfly_log);
    lua_setglobal(L, "dragonfly_log");
    if (g_iprep)
    {
        lua_pushcfunction(L, dragonfly_iprep);
        lua_setglobal(L, "dragonfly_iprep");
    }

    /* initialize the script */
    lua_getglobal(L, "initialize");
    if (lua_pcall(L, 0, 0, 0))
    {
        syslog(LOG_ERR, "%s error; %s", lua_analyzer, lua_tostring(L, -1));
        pthread_exit(NULL);
    }
    pthread_barrier_wait(&g_barrier);

    syslog(LOG_NOTICE, "Running %s\n", lua_analyzer);
    while (g_running)
    {
        int socket_handle = -1;
        if ((socket_handle = socket_open(socket_url)) < 0)
        {
            break;
        }
        lua_loop(L, socket_handle);
        socket_close(socket_handle);
    }
    lua_close(L);

    syslog(LOG_NOTICE, "%s exiting", lua_analyzer);
    pthread_exit(NULL);
}

/*
 * ---------------------------------------------------------------------------------------
 *
 * ---------------------------------------------------------------------------------------
 */

static void lua_start_threads(const char *dragonfly_root)
{
    struct stat sb;

    strncpy(g_root_dir, dragonfly_root, PATH_MAX);
    snprintf(g_run_dir, PATH_MAX, "%s/%s", dragonfly_root, RUN_DIR);
    snprintf(g_analyzer_dir, PATH_MAX, "%s/%s", dragonfly_root, ANALYZER_DIR);
    snprintf(g_config_file, PATH_MAX, "%s/%s", g_analyzer_dir, CONFIG_FILE);

    syslog(LOG_INFO, "root dir: %s\n", dragonfly_root);
    syslog(LOG_INFO, "run dir: %s\n", g_run_dir);
    syslog(LOG_INFO, "analyzer dir: %s\n", g_analyzer_dir);
    syslog(LOG_INFO, "config file: %s\n", g_config_file);

    if ((lstat(g_config_file, &sb) < 0) || !S_ISREG(sb.st_mode))
    {
        fprintf(stderr, "%s does not exist; assuming all default settings.\n", g_config_file);
        syslog(LOG_WARNING, "%s does noet exist; assuming all default settings.\n", g_config_file);
    }

    /* verify */

    lua_State *L = luaL_newstate();

    /*
     * Load config.lua
     */
    if (luaL_loadfile(L, g_config_file))
    {
        syslog(LOG_ERR, "luaL_loadfile failed; %s", lua_tostring(L, -1));
        abort();
    }

    if (lua_pcall(L, 0, 0, 0))
    {
        syslog(LOG_ERR, "lua_pcall failed; %s", lua_tostring(L, -1));
        abort();
    }

    lua_getglobal(L, "redis_host");
    if (lua_isstring(L, -1))
    {
        g_redis_host = strdup(lua_tostring(L, -1));
    }

    lua_getglobal(L, "redis_port");
    if (lua_isstring(L, -1))
    {
        g_redis_port = strdup(lua_tostring(L, -1));
    }

    lua_getglobal(L, "analyzer_mode");
    if (lua_isstring(L, -1))
    {
        g_analyzer_mode = strdup(lua_tostring(L, -1));
    }
    lua_close(L);

    if (chdir(g_root_dir) != 0)
    {
        fprintf(stderr, "unable to chdir() to : %s", g_root_dir);
        exit(EXIT_FAILURE);
    }
    syslog(LOG_INFO, "chdir: %s\n", getcwd(g_root_dir, PATH_MAX));

    for (int i = 0; g_analyzer_type[i] != NULL; i++)
    {
        struct stat sb;
        char lua_analyzer[PATH_MAX];
        snprintf(lua_analyzer, PATH_MAX - 1, "%s/%s-%s.lua", g_analyzer_dir, g_analyzer_type[i], g_analyzer_mode);
        /*
         * check that file exists with execute permissions 
         */
        if ((lstat(lua_analyzer, &sb) >= 0) && S_ISREG(sb.st_mode))
        {
            g_num_lua_threads++;
        }
    }

    pthread_barrier_init(&g_barrier, NULL, g_num_lua_threads + 1);

    for (int i = 0; g_analyzer_type[i] != NULL; i++)
    {
        struct stat sb;
        char lua_analyzer[PATH_MAX];
        snprintf(lua_analyzer, PATH_MAX - 1, "%s/%s-%s.lua", g_analyzer_dir, g_analyzer_type[i], g_analyzer_mode);
        /*
         * check that file exists with execute permissions 
         */
        pthread_t thread;
        if ((lstat(lua_analyzer, &sb) >= 0) && S_ISREG(sb.st_mode))
        {
            if (pthread_create(&thread, NULL, lua_thread, (void *)g_analyzer_type[i]) != 0)
            {
                syslog(LOG_ERR, "pthread_create() %s", strerror(errno));
                pthread_exit(NULL);
            }
        }
    }

    if (chdir(g_run_dir) != 0)
    {
        fprintf(stderr, "unable to chdir() to : %s", g_run_dir);
        exit(EXIT_FAILURE);
    }

    if (g_iprep && strncasecmp(g_analyzer_mode, SURICATA_MODE, 8) == 0)
    {
        /*
         * Enable iprep feature
         */

        /*
         * Caution: suri_command_connect() operates relative to chdir (g_run_dir) 
         *	    so that it works if chroot() is in effect. See above.
         */
        if (suricata_command_connect() < 0)
        {
            syslog(LOG_ERR, "suricata_command_connect failed");
            exit(EXIT_FAILURE);
        }
    }

    /*
     * Caution: The path below must be defined relative to chdir (g_run_dir) 
     *		so that it works if chroot() is in effect. See above.
     */
    snprintf(g_log_dir, PATH_MAX, "%s", g_analyzer_dir);
    dragonfly_init(g_log_dir);

    if (g_chroot)
    {
        if (chroot(g_run_dir) != 0)
        {
            fprintf(stderr, "unable to chroot() to : %s\n", g_run_dir);
            exit(EXIT_FAILURE);
        }
        syslog(LOG_INFO, "chroot: %s\n", g_run_dir);
    }

    if (g_drop_priv)
    {
        struct passwd *pwd = getpwnam(USER_NOBODY);
        if (getuid() == 0)
        {
            /* process is running as root, drop privileges */
            if (pwd && setuid(pwd->pw_uid) != 0)
            {
                syslog(LOG_ERR, "setuid: unable to drop user privileges: %s", strerror(errno));
                exit(EXIT_FAILURE);
            }
        }
        syslog(LOG_INFO, "dropped privileges: %s\n", USER_NOBODY);
    }
    /*
     * Wait until all analyzer threads are ready
     */
    pthread_barrier_wait(&g_barrier);
}

/*
 * ---------------------------------------------------------------------------------------
 *
 * ---------------------------------------------------------------------------------------
 */

void lua_analyzers_launch(const char *root_directory)
{
    g_verbose = isatty(1);
    lua_start_threads(root_directory);
}

    /*
 * ---------------------------------------------------------------------------------------
 *
 * ---------------------------------------------------------------------------------------
 */

#ifdef UNIT_TEST
int main(void)
{
    openlog("dragonfly", LOG_PERROR, LOG_USER);
    dragonfly_start("dragonfly-config.lua");
    closelog();
}
#endif

/*
 * ---------------------------------------------------------------------------------------
 */
